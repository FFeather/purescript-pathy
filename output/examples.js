// Generated by psc version 0.6.8
var PS = PS || {};
PS.Prelude = (function () {
    "use strict";
    
    function showStringImpl(s) {
      return JSON.stringify(s);
    }
    ;
    
    function showNumberImpl(n) {
      return n.toString();
    }
    ;
    
    function numAdd(n1) {
      return function(n2) {
        return n1 + n2;
      };
    }
    ;
    
    function numSub(n1) {
      return function(n2) {
        return n1 - n2;
      };
    }
    ;
    
    function numMul(n1) {
      return function(n2) {
        return n1 * n2;
      };
    }
    ;
    
    function refEq(r1) {
      return function(r2) {
        return r1 === r2;
      };
    }
    ;
    
    function refIneq(r1) {
      return function(r2) {
        return r1 !== r2;
      };
    }
    ;
    
    function unsafeCompareImpl(lt) {
      return function(eq) {
        return function(gt) {
          return function(x) {
            return function(y) {
              return x < y ? lt : x > y ? gt : eq;
            };
          };
        };
      };
    }
    ;
    
    function numShl(n1) {
      return function(n2) {
        return n1 << n2;
      };
    }
    ;
    
    function numShr(n1) {
      return function(n2) {
        return n1 >> n2;
      };
    }
    ;
    
    function numZshr(n1) {
      return function(n2) {
        return n1 >>> n2;
      };
    }
    ;
    
    function numAnd(n1) {
      return function(n2) {
        return n1 & n2;
      };
    }
    ;
    
    function numOr(n1) {
      return function(n2) {
        return n1 | n2;
      };
    }
    ;
    
    function numXor(n1) {
      return function(n2) {
        return n1 ^ n2;
      };
    }
    ;
    
    function numComplement(n) {
      return ~n;
    }
    ;
    
    function boolAnd(b1) {
      return function(b2) {
        return b1 && b2;
      };
    }
    ;
    
    function boolOr(b1) {
      return function(b2) {
        return b1 || b2;
      };
    }
    ;
    
    function boolNot(b) {
      return !b;
    }
    ;
    
    function concatString(s1) {
      return function(s2) {
        return s1 + s2;
      };
    }
    ;
    var LT = (function () {
        function LT() {

        };
        LT.value = new LT();
        return LT;
    })();
    var GT = (function () {
        function GT() {

        };
        GT.value = new GT();
        return GT;
    })();
    var EQ = (function () {
        function EQ() {

        };
        EQ.value = new EQ();
        return EQ;
    })();
    var Semigroupoid = function ($less$less$less) {
        this["<<<"] = $less$less$less;
    };
    var Category = function (__superclass_Prelude$dotSemigroupoid_0, id) {
        this["__superclass_Prelude.Semigroupoid_0"] = __superclass_Prelude$dotSemigroupoid_0;
        this.id = id;
    };
    var Show = function (show) {
        this.show = show;
    };
    var Functor = function ($less$dollar$greater) {
        this["<$>"] = $less$dollar$greater;
    };
    var Apply = function ($less$times$greater, __superclass_Prelude$dotFunctor_0) {
        this["<*>"] = $less$times$greater;
        this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    };
    var Applicative = function (__superclass_Prelude$dotApply_0, pure) {
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
        this.pure = pure;
    };
    var Bind = function ($greater$greater$eq, __superclass_Prelude$dotApply_0) {
        this[">>="] = $greater$greater$eq;
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
    };
    var Monad = function (__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
        this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
        this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
    };
    
    /**
     *  | Addition and multiplication
     */
    var Semiring = function ($times, $plus, one, zero) {
        this["*"] = $times;
        this["+"] = $plus;
        this.one = one;
        this.zero = zero;
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var Ring = function ($minus, __superclass_Prelude$dotSemiring_0) {
        this["-"] = $minus;
        this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
    };
    var Eq = function ($div$eq, $eq$eq) {
        this["/="] = $div$eq;
        this["=="] = $eq$eq;
    };
    var Ord = function (__superclass_Prelude$dotEq_0, compare) {
        this["__superclass_Prelude.Eq_0"] = __superclass_Prelude$dotEq_0;
        this.compare = compare;
    };
    var Bits = function ($dot$amp$dot, $dot$up$dot, $dot$bar$dot, complement, shl, shr, zshr) {
        this[".&."] = $dot$amp$dot;
        this[".^."] = $dot$up$dot;
        this[".|."] = $dot$bar$dot;
        this.complement = complement;
        this.shl = shl;
        this.shr = shr;
        this.zshr = zshr;
    };
    var BoolLike = function ($amp$amp, not, $bar$bar) {
        this["&&"] = $amp$amp;
        this.not = not;
        this["||"] = $bar$bar;
    };
    var Semigroup = function ($less$greater) {
        this["<>"] = $less$greater;
    };
    var $bar$bar = function (dict) {
        return dict["||"];
    };
    var $greater$greater$eq = function (dict) {
        return dict[">>="];
    };
    var $eq$eq = function (dict) {
        return dict["=="];
    };
    var $less$greater = function (dict) {
        return dict["<>"];
    };
    var $less$less$less = function (dict) {
        return dict["<<<"];
    };
    var $greater$greater$greater = function (__dict_Semigroupoid_0) {
        return function (f) {
            return function (g) {
                return $less$less$less(__dict_Semigroupoid_0)(g)(f);
            };
        };
    };
    var $less$times$greater = function (dict) {
        return dict["<*>"];
    };
    var $less$dollar$greater = function (dict) {
        return dict["<$>"];
    };
    var $div$eq = function (dict) {
        return dict["/="];
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var $minus = function (dict) {
        return dict["-"];
    };
    var $plus$plus = function (__dict_Semigroup_2) {
        return $less$greater(__dict_Semigroup_2);
    };
    
    /**
     *  | Addition and multiplication
     */
    var $plus = function (dict) {
        return dict["+"];
    };
    var $amp$amp = function (dict) {
        return dict["&&"];
    };
    var $dollar = function (f) {
        return function (x) {
            return f(x);
        };
    };
    
    /**
     *  | Addition and multiplication
     */
    var zero = function (dict) {
        return dict.zero;
    };
    var unsafeCompare = unsafeCompareImpl(LT.value)(EQ.value)(GT.value);
    var showString = new Show(showStringImpl);
    var showNumber = new Show(showNumberImpl);
    var show = function (dict) {
        return dict.show;
    };
    var semiringNumber = new Semiring(numMul, numAdd, 1, 0);
    var semigroupoidArr = new Semigroupoid(function (f) {
        return function (g) {
            return function (x) {
                return f(g(x));
            };
        };
    });
    var semigroupString = new Semigroup(concatString);
    var ringNumber = new Ring(numSub, function () {
        return semiringNumber;
    });
    var pure = function (dict) {
        return dict.pure;
    };
    var $$return = function (__dict_Monad_5) {
        return pure(__dict_Monad_5["__superclass_Prelude.Applicative_0"]());
    };
    var not = function (dict) {
        return dict.not;
    };
    var negate = function (__dict_Ring_6) {
        return function (a) {
            return $minus(__dict_Ring_6)(zero(__dict_Ring_6["__superclass_Prelude.Semiring_0"]()))(a);
        };
    };
    var liftA1 = function (__dict_Applicative_8) {
        return function (f) {
            return function (a) {
                return $less$times$greater(__dict_Applicative_8["__superclass_Prelude.Apply_0"]())(pure(__dict_Applicative_8)(f))(a);
            };
        };
    };
    var id = function (dict) {
        return dict.id;
    };
    
    /**
     *  | Flips the order of the arguments to a function of two arguments.
     */
    var flip = function (f) {
        return function (b) {
            return function (a) {
                return f(a)(b);
            };
        };
    };
    var eqString = new Eq(refIneq, refEq);
    var eqNumber = new Eq(refIneq, refEq);
    var ordNumber = new Ord(function () {
        return eqNumber;
    }, unsafeCompare);
    
    /**
     *  | Returns its first argument and ignores its second.
     */
    var $$const = function (_35) {
        return function (_36) {
            return _35;
        };
    };
    var complement = function (dict) {
        return dict.complement;
    };
    var compare = function (dict) {
        return dict.compare;
    };
    var $less = function (__dict_Ord_12) {
        return function (a1) {
            return function (a2) {
                var _643 = compare(__dict_Ord_12)(a1)(a2);
                if (_643 instanceof LT) {
                    return true;
                };
                return false;
            };
        };
    };
    var $greater = function (__dict_Ord_14) {
        return function (a1) {
            return function (a2) {
                var _644 = compare(__dict_Ord_14)(a1)(a2);
                if (_644 instanceof GT) {
                    return true;
                };
                return false;
            };
        };
    };
    var $greater$eq = function (__dict_Ord_15) {
        return function (a1) {
            return function (a2) {
                var _645 = compare(__dict_Ord_15)(a1)(a2);
                if (_645 instanceof LT) {
                    return false;
                };
                return true;
            };
        };
    };
    var categoryArr = new Category(function () {
        return semigroupoidArr;
    }, function (x) {
        return x;
    });
    var boolLikeBoolean = new BoolLike(boolAnd, boolNot, boolOr);
    var bitsNumber = new Bits(numAnd, numXor, numOr, numComplement, numShl, numShr, numZshr);
    var ap = function (__dict_Monad_16) {
        return function (f) {
            return function (a) {
                return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(f)(function (_2) {
                    return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(a)(function (_1) {
                        return $$return(__dict_Monad_16)(_2(_1));
                    });
                });
            };
        };
    };
    return {
        LT: LT, 
        GT: GT, 
        EQ: EQ, 
        Semigroup: Semigroup, 
        BoolLike: BoolLike, 
        Bits: Bits, 
        Ord: Ord, 
        Eq: Eq, 
        Ring: Ring, 
        Semiring: Semiring, 
        Monad: Monad, 
        Bind: Bind, 
        Applicative: Applicative, 
        Apply: Apply, 
        Functor: Functor, 
        Show: Show, 
        Category: Category, 
        Semigroupoid: Semigroupoid, 
        "++": $plus$plus, 
        "<>": $less$greater, 
        not: not, 
        "||": $bar$bar, 
        "&&": $amp$amp, 
        complement: complement, 
        ">=": $greater$eq, 
        ">": $greater, 
        "<": $less, 
        compare: compare, 
        refIneq: refIneq, 
        refEq: refEq, 
        "/=": $div$eq, 
        "==": $eq$eq, 
        negate: negate, 
        "-": $minus, 
        zero: zero, 
        "+": $plus, 
        ap: ap, 
        "return": $$return, 
        ">>=": $greater$greater$eq, 
        liftA1: liftA1, 
        pure: pure, 
        "<*>": $less$times$greater, 
        "<$>": $less$dollar$greater, 
        show: show, 
        "$": $dollar, 
        id: id, 
        ">>>": $greater$greater$greater, 
        "<<<": $less$less$less, 
        "const": $$const, 
        flip: flip, 
        semigroupoidArr: semigroupoidArr, 
        categoryArr: categoryArr, 
        showString: showString, 
        showNumber: showNumber, 
        semiringNumber: semiringNumber, 
        ringNumber: ringNumber, 
        eqString: eqString, 
        eqNumber: eqNumber, 
        ordNumber: ordNumber, 
        bitsNumber: bitsNumber, 
        boolLikeBoolean: boolLikeBoolean, 
        semigroupString: semigroupString
    };
})();
var PS = PS || {};
PS.Prelude_Unsafe = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    function unsafeIndex(xs) {
      return function(n) {
        return xs[n];
      };
    }
    ;
    return {
        unsafeIndex: unsafeIndex
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    function returnE(a) {
      return function() {
        return a;
      };
    }
    ;
    
    function bindE(a) {
      return function(f) {
        return function() {
          return f(a())();
        };
      };
    }
    ;
    var monadEff = new Prelude.Monad(function () {
        return applicativeEff;
    }, function () {
        return bindEff;
    });
    var bindEff = new Prelude.Bind(bindE, function () {
        return applyEff;
    });
    var applyEff = new Prelude.Apply(Prelude.ap(monadEff), function () {
        return functorEff;
    });
    var applicativeEff = new Prelude.Applicative(function () {
        return applyEff;
    }, returnE);
    var functorEff = new Prelude.Functor(Prelude.liftA1(applicativeEff));
    return {
        bindE: bindE, 
        returnE: returnE, 
        functorEff: functorEff, 
        applyEff: applyEff, 
        applicativeEff: applicativeEff, 
        bindEff: bindEff, 
        monadEff: monadEff
    };
})();
var PS = PS || {};
PS.Debug_Trace = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    
    function trace(s) {
      return function() {
        console.log(s);
        return {};
      };
    }
    ;
    return {
        trace: trace
    };
})();
var PS = PS || {};
PS.Data_Either = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Alt = PS.Control_Alt;
    var Control_Extend = PS.Control_Extend;
    
    /**
     *  | The `Either` type is used to represent a choice between two types of value.
     *  |
     *  | A common use case for `Either` is error handling, where `Left` is used to
     *  | carry an error value and `Right` is used to carry a success value.
     */
    var Left = (function () {
        function Left(value0) {
            this.value0 = value0;
        };
        Left.create = function (value0) {
            return new Left(value0);
        };
        return Left;
    })();
    
    /**
     *  | The `Either` type is used to represent a choice between two types of value.
     *  |
     *  | A common use case for `Either` is error handling, where `Left` is used to
     *  | carry an error value and `Right` is used to carry a success value.
     */
    var Right = (function () {
        function Right(value0) {
            this.value0 = value0;
        };
        Right.create = function (value0) {
            return new Right(value0);
        };
        return Right;
    })();
    
    /**
     *  | Takes two functions and an `Either` value, if the value is a `Left` the
     *  | inner value is applied to the first function, if the value is a `Right`
     *  | the inner value is applied to the second function.
     *  |
     *  | ``` purescript
     *  | either f g (Left x) == f x
     *  | either f g (Right y) == g y
     *  | ```
     */
    var either = function (_91) {
        return function (_92) {
            return function (_93) {
                if (_93 instanceof Left) {
                    return _91(_93.value0);
                };
                if (_93 instanceof Right) {
                    return _92(_93.value0);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
    return {
        Left: Left, 
        Right: Right, 
        either: either
    };
})();
var PS = PS || {};
PS.Data_Maybe = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Alt = PS.Control_Alt;
    var Control_Alternative = PS.Control_Alternative;
    var Control_Extend = PS.Control_Extend;
    var Control_MonadPlus = PS.Control_MonadPlus;
    var Control_Plus = PS.Control_Plus;
    
    /**
     *  | The `Maybe` type is used to represent optional values and can be seen as
     *  | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
     *  | is the non-null value `x`.
     */
    var Nothing = (function () {
        function Nothing() {

        };
        Nothing.value = new Nothing();
        return Nothing;
    })();
    
    /**
     *  | The `Maybe` type is used to represent optional values and can be seen as
     *  | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
     *  | is the non-null value `x`.
     */
    var Just = (function () {
        function Just(value0) {
            this.value0 = value0;
        };
        Just.create = function (value0) {
            return new Just(value0);
        };
        return Just;
    })();
    
    /**
     *  | The `Show` instance allows `Maybe` values to be rendered as a string with
     *  | `show` whenever there is an `Show` instance for the type the `Maybe`
     *  | contains.
     */
    var showMaybe = function (__dict_Show_85) {
        return new Prelude.Show(function (_126) {
            if (_126 instanceof Just) {
                return "Just (" + (Prelude.show(__dict_Show_85)(_126.value0) + ")");
            };
            if (_126 instanceof Nothing) {
                return "Nothing";
            };
            throw new Error("Failed pattern match");
        });
    };
    
    /**
     *  | Takes a default value, a function, and a `Maybe` value. If the `Maybe`
     *  | value is `Nothing` the default value is returned, otherwise the function
     *  | is applied to the value inside the `Just` and the result is returned.
     *  |
     *  | ``` purescript
     *  | maybe x f Nothing == x
     *  | maybe x f (Just y) == f y
     *  | ```
     */
    var maybe = function (_111) {
        return function (_112) {
            return function (_113) {
                if (_113 instanceof Nothing) {
                    return _111;
                };
                if (_113 instanceof Just) {
                    return _112(_113.value0);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
    
    /**
     *  | The `Functor` instance allows functions to transform the contents of a
     *  | `Just` with the `<$>` operator:
     *  |
     *  | ``` purescript
     *  | f <$> Just x == Just (f x)
     *  | ```
     *  |
     *  | `Nothing` values are left untouched:
     *  |
     *  | ``` purescript
     *  | f <$> Nothing == Nothing
     *  | ```
     */
    var functorMaybe = new Prelude.Functor(function (_114) {
        return function (_115) {
            if (_115 instanceof Just) {
                return new Just(_114(_115.value0));
            };
            return Nothing.value;
        };
    });
    
    /**
     *  | The `Eq` instance allows `Maybe` values to be checked for equality with
     *  | `==` and inequality with `/=` whenever there is an `Eq` instance for the
     *  | type the `Maybe` contains.
     */
    var eqMaybe = function (__dict_Eq_88) {
        return new Prelude.Eq(function (a) {
            return function (b) {
                return !Prelude["=="](eqMaybe(__dict_Eq_88))(a)(b);
            };
        }, function (_127) {
            return function (_128) {
                if (_127 instanceof Nothing && _128 instanceof Nothing) {
                    return true;
                };
                if (_127 instanceof Just && _128 instanceof Just) {
                    return Prelude["=="](__dict_Eq_88)(_127.value0)(_128.value0);
                };
                return false;
            };
        });
    };
    return {
        Nothing: Nothing, 
        Just: Just, 
        maybe: maybe, 
        functorMaybe: functorMaybe, 
        showMaybe: showMaybe, 
        eqMaybe: eqMaybe
    };
})();
var PS = PS || {};
PS.Data_Array = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Maybe = PS.Data_Maybe;
    var Control_Alt = PS.Control_Alt;
    var Control_Plus = PS.Control_Plus;
    var Control_Alternative = PS.Control_Alternative;
    var Control_MonadPlus = PS.Control_MonadPlus;
    var Prelude_Unsafe = PS.Prelude_Unsafe;
    function length (xs) {  return xs.length;};
    function filter (f) {  return function (arr) {    var n = 0;    var result = [];    for (var i = 0, l = arr.length; i < l; i++) {      if (f(arr[i])) {        result[n++] = arr[i];      }    }    return result;  };};
    function range (start) {  return function (end) {    var i = ~~start, e = ~~end;    var step = i > e ? -1 : 1;    var result = [i], n = 1;    while (i !== e) {      i += step;      result[n++] = i;    }    return result;  };};
    function zipWith (f) {  return function (xs) {    return function (ys) {      var l = xs.length < ys.length ? xs.length : ys.length;      var result = new Array(l);      for (var i = 0; i < l; i++) {        result[i] = f(xs[i])(ys[i]);      }      return result;    };  };};
    
    /**
     *  | This operator provides a safe way to read a value at a particular index from an array.
     *  |
     *  | This function returns `Nothing` if the index is out-of-bounds.
     *  |
     *  | `Data.Array.Unsafe` provides the `unsafeIndex` function, which is an unsafe version of
     *  | this function without bounds checking.
     */
    var $bang$bang = function (xs) {
        return function (n) {
            var isInt = function (n_1) {
                return n_1 !== ~~n_1;
            };
            var _666 = n < 0 || (n >= length(xs) || isInt(n));
            if (_666) {
                return Data_Maybe.Nothing.value;
            };
            if (!_666) {
                return new Data_Maybe.Just(xs[n]);
            };
            throw new Error("Failed pattern match");
        };
    };
    return {
        zipWith: zipWith, 
        range: range, 
        filter: filter, 
        length: length, 
        "!!": $bang$bang
    };
})();
var PS = PS || {};
PS.Data_Maybe_Unsafe = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Maybe = PS.Data_Maybe;
    
    /**
     *  | A partial function that extracts the value from the `Just` data
     *  | constructor. Passing `Nothing` to `fromJust` will throw an error at
     *  | runtime.
     */
    var fromJust = function (_150) {
        if (_150 instanceof Data_Maybe.Just) {
            return _150.value0;
        };
        throw new Error("Failed pattern match");
    };
    return {
        fromJust: fromJust
    };
})();
var PS = PS || {};
PS.Data_Monoid = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Array = PS.Data_Array;
    var Data_Maybe = PS.Data_Maybe;
    var mempty = function (dict) {
        return dict.mempty;
    };
    return {
        mempty: mempty
    };
})();
var PS = PS || {};
PS.Data_Tuple = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Monoid = PS.Data_Monoid;
    var Control_Lazy = PS.Control_Lazy;
    var Data_Array = PS.Data_Array;
    var Control_Comonad = PS.Control_Comonad;
    var Control_Extend = PS.Control_Extend;
    
    /**
     *  | A simple product type for wrapping a pair of component values.
     */
    var Tuple = (function () {
        function Tuple(value0, value1) {
            this.value0 = value0;
            this.value1 = value1;
        };
        Tuple.create = function (value0) {
            return function (value1) {
                return new Tuple(value0, value1);
            };
        };
        return Tuple;
    })();
    
    /**
     *  | Returns the second component of a tuple.
     */
    var snd = function (_235) {
        return _235.value1;
    };
    
    /**
     *  | The `Functor` instance allows functions to transform the contents of a
     *  | `Tuple` with the `<$>` operator, applying the function to the second
     *  | component, so:
     *  | ```purescript
     *  | f <$> (Tuple x y) = Tuple x (f y)
     *  | ````
     */
    var functorTuple = new Prelude.Functor(function (_249) {
        return function (_250) {
            return new Tuple(_250.value0, _249(_250.value1));
        };
    });
    return {
        Tuple: Tuple, 
        snd: snd, 
        functorTuple: functorTuple
    };
})();
var PS = PS || {};
PS.Data_Foldable = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Monoid = PS.Data_Monoid;
    var Control_Apply = PS.Control_Apply;
    var Data_Monoid_First = PS.Data_Monoid_First;
    var Data_Either = PS.Data_Either;
    var Data_Maybe = PS.Data_Maybe;
    var Data_Monoid_Additive = PS.Data_Monoid_Additive;
    var Data_Monoid_Dual = PS.Data_Monoid_Dual;
    var Data_Monoid_Last = PS.Data_Monoid_Last;
    var Data_Monoid_Multiplicative = PS.Data_Monoid_Multiplicative;
    var Data_Tuple = PS.Data_Tuple;
    
  function foldrArray(f) {
    return function(z) {
      return function(xs) {
        var acc = z;
        for (var i = xs.length - 1; i >= 0; --i) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  }
  ;
    
  function foldlArray(f) {
    return function(z) {
      return function(xs) {
        var acc = z;
        for (var i = 0, len = xs.length; i < len; ++i) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  }
  ;
    
    /**
     *  | `Foldable` represents data structures which can be _folded_.
     *  |
     *  | - `foldr` folds a structure from the right
     *  | - `foldl` folds a structure from the left
     *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
     */
    var Foldable = function (foldMap, foldl, foldr) {
        this.foldMap = foldMap;
        this.foldl = foldl;
        this.foldr = foldr;
    };
    
    /**
     *  | `Foldable` represents data structures which can be _folded_.
     *  |
     *  | - `foldr` folds a structure from the right
     *  | - `foldl` folds a structure from the left
     *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
     */
    var foldr = function (dict) {
        return dict.foldr;
    };
    var foldableArray = new Foldable(function (__dict_Monoid_321) {
        return function (f) {
            return function (xs) {
                return foldr(foldableArray)(function (x) {
                    return function (acc) {
                        return Prelude["<>"](__dict_Monoid_321["__superclass_Prelude.Semigroup_0"]())(f(x))(acc);
                    };
                })(Data_Monoid.mempty(__dict_Monoid_321))(xs);
            };
        };
    }, function (f) {
        return function (z) {
            return function (xs) {
                return foldlArray(f)(z)(xs);
            };
        };
    }, function (f) {
        return function (z) {
            return function (xs) {
                return foldrArray(f)(z)(xs);
            };
        };
    });
    return {
        Foldable: Foldable, 
        foldlArray: foldlArray, 
        foldrArray: foldrArray, 
        foldr: foldr, 
        foldableArray: foldableArray
    };
})();
var PS = PS || {};
PS.Data_String = (function () {
    "use strict";
    var Data_Function = PS.Data_Function;
    var Data_Char = PS.Data_Char;
    var Prelude = PS.Prelude;
    var Data_String_Unsafe = PS.Data_String_Unsafe;
    var Data_Maybe = PS.Data_Maybe;
    
    function lastIndexOf(x) {
      return function(s) {
        return s.lastIndexOf(x);
      };
    }
    ;
    
    function length(s) {
      return s.length;
    }
    ;
    
    function take(n) {
      return function(s) {
        return s.substr(0, n);
      };
    }
    ;
    
    function drop(n) {
      return function(s) {
        return s.substr(n);
      };
    }
    ;
    
    function split(sep) {
      return function(s) {
        return s.split(sep);
      };
    }
    ;
    
    function joinWith(s) {
      return function(xs) {
        return xs.join(s);
      };
    }
    ;
    return {
        joinWith: joinWith, 
        split: split, 
        drop: drop, 
        take: take, 
        length: length, 
        lastIndexOf: lastIndexOf
    };
})();
var PS = PS || {};
PS.Data_Path_Pathy = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_String = PS.Data_String;
    var Data_Array = PS.Data_Array;
    var Data_Tuple = PS.Data_Tuple;
    var Data_Either = PS.Data_Either;
    var Data_Maybe = PS.Data_Maybe;
    var Data_Foldable = PS.Data_Foldable;
    var Control_Alt = PS.Control_Alt;
    var Data_List = PS.Data_List;
    var Data_Profunctor_Strong = PS.Data_Profunctor_Strong;
    
    /**
     *  | A newtype around a file name.
     */
    var FileName = function (x) {
        return x;
    };
    
    /**
     *  | Escapers encode segments or characters which have reserved meaning.
     */
    var Escaper = function (x) {
        return x;
    };
    
    /**
     *  | A newtype around a directory name.
     */
    var DirName = function (x) {
        return x;
    };
    
    /**
     *  | A type that describes a Path. All flavors of paths are described by this 
     *  | type, whether they are absolute or relative paths, whether they 
     *  | refer to files or directories, whether they are sandboxed or not.
     *  | 
     *  | * The type parameter `a` describes whether the path is `Rel` or `Abs`.
     *  | * The type parameter `b` describes whether the path is `File` or `Dir`.
     *  | * The type parameter `s` describes whether the path is `Sandboxed` or `Unsandboxed`.
     *  |
     *  | To ensure type safety, there is no way for users to create a value of 
     *  | this type directly. Instead, helpers should be used, such as `rootDir`,
     *  | `currentDir`, `file`, `dir`,  `(</>)`, and `parsePath`.
     *  | 
     *  | This ADT allows invalid paths (e.g. paths inside files), but there is no
     *  | possible way for such paths to be constructed by user-land code. The only
     *  | "invalid path" that may be constructed is using the `parentDir'` function, e.g.
     *  | `parentDir' rootDir`, or by parsing an equivalent string such as `/../`, 
     *  | but such paths are marked as unsandboxed, and may not be rendered to strings
     *  | until they are first sandboxed to some directory.
     */
    var Current = (function () {
        function Current() {

        };
        Current.value = new Current();
        return Current;
    })();
    
    /**
     *  | A type that describes a Path. All flavors of paths are described by this 
     *  | type, whether they are absolute or relative paths, whether they 
     *  | refer to files or directories, whether they are sandboxed or not.
     *  | 
     *  | * The type parameter `a` describes whether the path is `Rel` or `Abs`.
     *  | * The type parameter `b` describes whether the path is `File` or `Dir`.
     *  | * The type parameter `s` describes whether the path is `Sandboxed` or `Unsandboxed`.
     *  |
     *  | To ensure type safety, there is no way for users to create a value of 
     *  | this type directly. Instead, helpers should be used, such as `rootDir`,
     *  | `currentDir`, `file`, `dir`,  `(</>)`, and `parsePath`.
     *  | 
     *  | This ADT allows invalid paths (e.g. paths inside files), but there is no
     *  | possible way for such paths to be constructed by user-land code. The only
     *  | "invalid path" that may be constructed is using the `parentDir'` function, e.g.
     *  | `parentDir' rootDir`, or by parsing an equivalent string such as `/../`, 
     *  | but such paths are marked as unsandboxed, and may not be rendered to strings
     *  | until they are first sandboxed to some directory.
     */
    var Root = (function () {
        function Root() {

        };
        Root.value = new Root();
        return Root;
    })();
    
    /**
     *  | A type that describes a Path. All flavors of paths are described by this 
     *  | type, whether they are absolute or relative paths, whether they 
     *  | refer to files or directories, whether they are sandboxed or not.
     *  | 
     *  | * The type parameter `a` describes whether the path is `Rel` or `Abs`.
     *  | * The type parameter `b` describes whether the path is `File` or `Dir`.
     *  | * The type parameter `s` describes whether the path is `Sandboxed` or `Unsandboxed`.
     *  |
     *  | To ensure type safety, there is no way for users to create a value of 
     *  | this type directly. Instead, helpers should be used, such as `rootDir`,
     *  | `currentDir`, `file`, `dir`,  `(</>)`, and `parsePath`.
     *  | 
     *  | This ADT allows invalid paths (e.g. paths inside files), but there is no
     *  | possible way for such paths to be constructed by user-land code. The only
     *  | "invalid path" that may be constructed is using the `parentDir'` function, e.g.
     *  | `parentDir' rootDir`, or by parsing an equivalent string such as `/../`, 
     *  | but such paths are marked as unsandboxed, and may not be rendered to strings
     *  | until they are first sandboxed to some directory.
     */
    var ParentIn = (function () {
        function ParentIn(value0) {
            this.value0 = value0;
        };
        ParentIn.create = function (value0) {
            return new ParentIn(value0);
        };
        return ParentIn;
    })();
    
    /**
     *  | A type that describes a Path. All flavors of paths are described by this 
     *  | type, whether they are absolute or relative paths, whether they 
     *  | refer to files or directories, whether they are sandboxed or not.
     *  | 
     *  | * The type parameter `a` describes whether the path is `Rel` or `Abs`.
     *  | * The type parameter `b` describes whether the path is `File` or `Dir`.
     *  | * The type parameter `s` describes whether the path is `Sandboxed` or `Unsandboxed`.
     *  |
     *  | To ensure type safety, there is no way for users to create a value of 
     *  | this type directly. Instead, helpers should be used, such as `rootDir`,
     *  | `currentDir`, `file`, `dir`,  `(</>)`, and `parsePath`.
     *  | 
     *  | This ADT allows invalid paths (e.g. paths inside files), but there is no
     *  | possible way for such paths to be constructed by user-land code. The only
     *  | "invalid path" that may be constructed is using the `parentDir'` function, e.g.
     *  | `parentDir' rootDir`, or by parsing an equivalent string such as `/../`, 
     *  | but such paths are marked as unsandboxed, and may not be rendered to strings
     *  | until they are first sandboxed to some directory.
     */
    var DirIn = (function () {
        function DirIn(value0, value1) {
            this.value0 = value0;
            this.value1 = value1;
        };
        DirIn.create = function (value0) {
            return function (value1) {
                return new DirIn(value0, value1);
            };
        };
        return DirIn;
    })();
    
    /**
     *  | A type that describes a Path. All flavors of paths are described by this 
     *  | type, whether they are absolute or relative paths, whether they 
     *  | refer to files or directories, whether they are sandboxed or not.
     *  | 
     *  | * The type parameter `a` describes whether the path is `Rel` or `Abs`.
     *  | * The type parameter `b` describes whether the path is `File` or `Dir`.
     *  | * The type parameter `s` describes whether the path is `Sandboxed` or `Unsandboxed`.
     *  |
     *  | To ensure type safety, there is no way for users to create a value of 
     *  | this type directly. Instead, helpers should be used, such as `rootDir`,
     *  | `currentDir`, `file`, `dir`,  `(</>)`, and `parsePath`.
     *  | 
     *  | This ADT allows invalid paths (e.g. paths inside files), but there is no
     *  | possible way for such paths to be constructed by user-land code. The only
     *  | "invalid path" that may be constructed is using the `parentDir'` function, e.g.
     *  | `parentDir' rootDir`, or by parsing an equivalent string such as `/../`, 
     *  | but such paths are marked as unsandboxed, and may not be rendered to strings
     *  | until they are first sandboxed to some directory.
     */
    var FileIn = (function () {
        function FileIn(value0, value1) {
            this.value0 = value0;
            this.value1 = value1;
        };
        FileIn.create = function (value0) {
            return function (value1) {
                return new FileIn(value0, value1);
            };
        };
        return FileIn;
    })();
    
    /**
     *  | Given a directory path, appends either a file or directory to the path.
     */
    var $less$div$greater = function (_622) {
        return function (_623) {
            if (_622 instanceof Current && _623 instanceof Current) {
                return Current.value;
            };
            if (_622 instanceof Root && _623 instanceof Current) {
                return Root.value;
            };
            if (_622 instanceof ParentIn && _623 instanceof Current) {
                return new ParentIn($less$div$greater(_622.value0)(Current.value));
            };
            if (_622 instanceof FileIn && _623 instanceof Current) {
                return new FileIn($less$div$greater(_622.value0)(Current.value), _622.value1);
            };
            if (_622 instanceof DirIn && _623 instanceof Current) {
                return new DirIn($less$div$greater(_622.value0)(Current.value), _622.value1);
            };
            if (_622 instanceof Current && _623 instanceof Root) {
                return Current.value;
            };
            if (_622 instanceof Root && _623 instanceof Root) {
                return Root.value;
            };
            if (_622 instanceof ParentIn && _623 instanceof Root) {
                return new ParentIn($less$div$greater(_622.value0)(Current.value));
            };
            if (_622 instanceof FileIn && _623 instanceof Root) {
                return new FileIn($less$div$greater(_622.value0)(Current.value), _622.value1);
            };
            if (_622 instanceof DirIn && _623 instanceof Root) {
                return new DirIn($less$div$greater(_622.value0)(Current.value), _622.value1);
            };
            if (_623 instanceof ParentIn) {
                return new ParentIn($less$div$greater(_622)(_623.value0));
            };
            if (_623 instanceof FileIn) {
                return new FileIn($less$div$greater(_622)(_623.value0), _623.value1);
            };
            if (_623 instanceof DirIn) {
                return new DirIn($less$div$greater(_622)(_623.value0), _623.value1);
            };
            throw new Error("Failed pattern match");
        };
    };
    
    /**
     *  | Unsandboxes any path (whether sandboxed or not).
     */
    var unsandbox = function (_631) {
        if (_631 instanceof Current) {
            return Current.value;
        };
        if (_631 instanceof Root) {
            return Root.value;
        };
        if (_631 instanceof ParentIn) {
            return new ParentIn(unsandbox(_631.value0));
        };
        if (_631 instanceof DirIn) {
            return new DirIn(unsandbox(_631.value0), _631.value1);
        };
        if (_631 instanceof FileIn) {
            return new FileIn(unsandbox(_631.value0), _631.value1);
        };
        throw new Error("Failed pattern match");
    };
    var unsafePrintPath$prime = function (r) {
        return function (p) {
            var go = function (_636) {
                if (_636 instanceof Current) {
                    return "./";
                };
                if (_636 instanceof Root) {
                    return "/";
                };
                if (_636 instanceof ParentIn) {
                    return go(_636.value0) + "../";
                };
                if (_636 instanceof DirIn && _636.value0 instanceof FileIn) {
                    return go(_636.value0) + ("/" + (_636.value1 + "/"));
                };
                if (_636 instanceof DirIn) {
                    return go(_636.value0) + (_636.value1 + "/");
                };
                if (_636 instanceof FileIn && _636.value0 instanceof FileIn) {
                    return go(_636.value0) + ("/" + _636.value1);
                };
                if (_636 instanceof FileIn) {
                    return go(_636.value0) + _636.value1;
                };
                throw new Error("Failed pattern match");
            };
            return go(p);
        };
    };
    var unsafeCoerceType = function (_632) {
        if (_632 instanceof Current) {
            return Current.value;
        };
        if (_632 instanceof Root) {
            return Root.value;
        };
        if (_632 instanceof ParentIn) {
            return new ParentIn(unsafeCoerceType(_632.value0));
        };
        if (_632 instanceof DirIn) {
            return new DirIn(unsafeCoerceType(_632.value0), _632.value1);
        };
        if (_632 instanceof FileIn) {
            return new FileIn(unsafeCoerceType(_632.value0), _632.value1);
        };
        throw new Error("Failed pattern match");
    };
    var showPath = new Prelude.Show(function (_640) {
        if (_640 instanceof Current) {
            return "currentDir";
        };
        if (_640 instanceof Root) {
            return "rootDir";
        };
        if (_640 instanceof ParentIn) {
            return "(parentDir' " + (Prelude.show(showPath)(_640.value0) + ")");
        };
        if (_640 instanceof FileIn) {
            return "(" + (Prelude.show(showPath)(_640.value0) + (" </> file " + (Prelude.show(Prelude.showString)(_640.value1) + ")")));
        };
        if (_640 instanceof DirIn) {
            return "(" + (Prelude.show(showPath)(_640.value0) + (" </> dir " + (Prelude.show(Prelude.showString)(_640.value1) + ")")));
        };
        throw new Error("Failed pattern match");
    });
    
    /**
     *  | Given an escaper and a segment to encode, returns the encoded segment.
     */
    var runEscaper = function (_616) {
        return _616;
    };
    
    /**
     *  | The root directory, which can be used to define absolutely-located resources.
     */
    var rootDir = Root.value;
    
    /**
     *  | Renames a file path.
     */
    var renameFile = function (f) {
        var go = function (_634) {
            if (_634 instanceof FileIn) {
                return new FileIn(_634.value0, f(_634.value1));
            };
            return _634;
        };
        return go;
    };
    
    /**
     *  | Parses a canonical `String` representation of a path into a `Path` value.
     *  | Note that in order to be unambiguous, trailing directories should be 
     *  | marked with a trailing slash character (`'/'`).
     */
    var parsePath = function (rf) {
        return function (af) {
            return function (rd) {
                return function (ad) {
                    return function (p) {
                        var segs = Data_Array.filter(function (s) {
                            return Data_String.length(s) > 0;
                        })(Data_String.split("/")(p));
                        var lastIndex = Data_Array.length(segs) - 1;
                        var tuples = Data_Array.zipWith(Data_Tuple.Tuple.create)(segs)(Data_Array.range(0)(lastIndex));
                        var isFile = Data_Maybe.maybe(false)(function (last) {
                            var _729 = last === "";
                            if (_729) {
                                return false;
                            };
                            if (!_729) {
                                return true;
                            };
                            throw new Error("Failed pattern match");
                        })(Data_Array["!!"](segs)(lastIndex));
                        var isAbs = Data_String.take(1)(p) === "/";
                        var folder = function (_638) {
                            return function (_639) {
                                if (_638.value1 === 0) {
                                    return Prelude["const"](_639((function () {
                                        var _733 = _638.value0 === ".";
                                        if (_733) {
                                            return Current.value;
                                        };
                                        if (!_733) {
                                            var _734 = _638.value0 === "..";
                                            if (_734) {
                                                return new ParentIn(Current.value);
                                            };
                                            if (!_734) {
                                                var _735 = _638.value0 === "";
                                                if (_735) {
                                                    return Root.value;
                                                };
                                                if (!_735) {
                                                    var _736 = _638.value1 === lastIndex;
                                                    if (_736) {
                                                        return new FileIn(Current.value, _638.value0);
                                                    };
                                                    if (!_736) {
                                                        return new DirIn(Current.value, _638.value0);
                                                    };
                                                    throw new Error("Failed pattern match");
                                                };
                                                throw new Error("Failed pattern match");
                                            };
                                            throw new Error("Failed pattern match");
                                        };
                                        throw new Error("Failed pattern match");
                                    })()));
                                };
                                var _737 = _638.value0 === ".";
                                if (_737) {
                                    return _639;
                                };
                                if (!_737) {
                                    var _738 = _638.value0 === "..";
                                    if (_738) {
                                        return function (p_1) {
                                            return new ParentIn(_639(p_1));
                                        };
                                    };
                                    if (!_738) {
                                        var _739 = _638.value0 === "";
                                        if (_739) {
                                            return _639;
                                        };
                                        if (!_739) {
                                            return function (p_1) {
                                                return new DirIn(_639(p_1), _638.value0);
                                            };
                                        };
                                        throw new Error("Failed pattern match");
                                    };
                                    throw new Error("Failed pattern match");
                                };
                                throw new Error("Failed pattern match");
                            };
                        };
                        var _742 = p === "";
                        if (_742) {
                            return rd(Current.value);
                        };
                        if (!_742) {
                            var _743 = isAbs && isFile;
                            if (_743) {
                                return af(Data_Foldable.foldr(Data_Foldable.foldableArray)(folder)(Prelude.id(Prelude.categoryArr))(tuples)(Root.value));
                            };
                            if (!_743) {
                                var _744 = isAbs && !isFile;
                                if (_744) {
                                    return ad(Data_Foldable.foldr(Data_Foldable.foldableArray)(folder)(Prelude.id(Prelude.categoryArr))(tuples)(Root.value));
                                };
                                if (!_744) {
                                    var _745 = !isAbs && isFile;
                                    if (_745) {
                                        return rf(Data_Foldable.foldr(Data_Foldable.foldableArray)(folder)(Prelude.id(Prelude.categoryArr))(tuples)(Root.value));
                                    };
                                    if (!_745) {
                                        return rd(Data_Foldable.foldr(Data_Foldable.foldableArray)(folder)(Prelude.id(Prelude.categoryArr))(tuples)(Root.value));
                                    };
                                    throw new Error("Failed pattern match");
                                };
                                throw new Error("Failed pattern match");
                            };
                            throw new Error("Failed pattern match");
                        };
                        throw new Error("Failed pattern match");
                    };
                };
            };
        };
    };
    
    /**
     *  | Attempts to parse a relative directory from a string.
     */
    var parseRelDir = parsePath(Prelude["const"](Data_Maybe.Nothing.value))(Prelude["const"](Data_Maybe.Nothing.value))(Data_Maybe.Just.create)(Prelude["const"](Data_Maybe.Nothing.value));
    
    /**
     *  | Attempts to parse a relative file from a string.
     */
    var parseRelFile = parsePath(Data_Maybe.Just.create)(Prelude["const"](Data_Maybe.Nothing.value))(Prelude["const"](Data_Maybe.Nothing.value))(Prelude["const"](Data_Maybe.Nothing.value));
    
    /**
     *  | Creates a path that points to the parent directory of the specified path.
     *  | This function always unsandboxes the path.
     */
    var parentDir$prime = Prelude["<<<"](Prelude.semigroupoidArr)(ParentIn.create)(Prelude["<<<"](Prelude.semigroupoidArr)(unsafeCoerceType)(unsandbox));
    
    /**
     *  | Ascends into the parent of the specified directory, then descends into 
     *  | the specified path. The result is always unsandboxed because it may escape
     *  | its previous sandbox.
     */
    var $less$dot$dot$greater = function (d) {
        return function (p) {
            return $less$div$greater(parentDir$prime(d))(unsandbox(p));
        };
    };
    
    /**
     *  | An escaper that does nothing except remove slashes (the bare minimum of
     *  | what must be done).
     */
    var nonEscaper = Escaper(function (s) {
        return Data_String.joinWith("")(Data_Array.filter(Prelude["/="](Prelude.eqString)("/"))(Data_String.split("")(s)));
    });
    
    /**
     *  | An escaper that removes all slashes, converts ".." into "$dot$dot", and
     *  | converts "." into "$dot".
     */
    var posixEscaper = Escaper(Prelude[">>>"](Prelude.semigroupoidArr)(runEscaper(nonEscaper))(function (s) {
        var _746 = s === "..";
        if (_746) {
            return "$dot$dot";
        };
        if (!_746) {
            var _747 = s === ".";
            if (_747) {
                return "$dot";
            };
            if (!_747) {
                return s;
            };
            throw new Error("Failed pattern match");
        };
        throw new Error("Failed pattern match");
    }));
    var unsafePrintPath = unsafePrintPath$prime(posixEscaper);
    
    /**
     *  | Determines if two paths have the exact same representation. Note that 
     *  | two paths may represent the same path even if they have different 
     *  | representations!
     */
    var identicalPath = function (p1) {
        return function (p2) {
            return Prelude.show(showPath)(p1) === Prelude.show(showPath)(p2);
        };
    };
    
    /**
     *  | Creates a path which points to a relative file of the specified name.
     */
    var file$prime = function (f) {
        return new FileIn(Current.value, f);
    };
    
    /**
     *  | Creates a path which points to a relative file of the specified name.
     */
    var file = function (f) {
        return file$prime(f);
    };
    
    /**
     *  | Retrieves the extension of a file name.
     */
    var extension = function (_618) {
        var idx = Data_String.lastIndexOf(".")(_618);
        var _749 = idx === -1;
        if (_749) {
            return "";
        };
        if (!_749) {
            return Data_String.drop(idx + 1)(_618);
        };
        throw new Error("Failed pattern match");
    };
    
    /**
     *  | Drops the extension on a file name.
     */
    var dropExtension = function (_619) {
        var idx = Data_String.lastIndexOf(".")(_619);
        var _751 = idx === -1;
        if (_751) {
            return _619;
        };
        if (!_751) {
            return FileName(Data_String.take(idx)(_619));
        };
        throw new Error("Failed pattern match");
    };
    
    /**
     *  | Creates a path which points to a relative directory of the specified name.
     */
    var dir$prime = function (d) {
        return new DirIn(Current.value, d);
    };
    
    /**
     *  | Creates a path which points to a relative directory of the specified name.
     */
    var dir = function (d) {
        return dir$prime(d);
    };
    
    /**
     *  | Returns the depth of the path. This may be negative in some cases, e.g.
     *  | `./../../../` has depth `-3`.
     */
    var depth = function (_630) {
        if (_630 instanceof Current) {
            return 0;
        };
        if (_630 instanceof Root) {
            return 0;
        };
        if (_630 instanceof ParentIn) {
            return depth(_630.value0) - 1;
        };
        if (_630 instanceof FileIn) {
            return depth(_630.value0) + 1;
        };
        if (_630 instanceof DirIn) {
            return depth(_630.value0) + 1;
        };
        throw new Error("Failed pattern match");
    };
    
    /**
     *  | The "current directory", which can be used to define relatively-located resources.
     */
    var currentDir = Current.value;
    
    /**
     *  | Changes the extension on a file name.
     */
    var changeExtension = function (_620) {
        return function (_621) {
            var ext = _620(extension(_621));
            return (function (_613) {
                var _761 = ext === "";
                if (_761) {
                    return _613;
                };
                if (!_761) {
                    return FileName(_613 + ("." + ext));
                };
                throw new Error("Failed pattern match");
            })(dropExtension(_621));
        };
    };
    
    /**
     *  | Sets the extension of the file to the specified extension.
     *  |
     *  | ```purescript
     *  | file "image" <.> "png"
     *  | ```
     */
    var $less$dot$greater = function (p) {
        return function (ext) {
            return renameFile(changeExtension(Prelude["const"](ext)))(p);
        };
    };
    
    /**
     *  | Canonicalizes a path and returns information on whether or not it actually changed.
     */
    var canonicalize$prime = function (_633) {
        if (_633 instanceof Current) {
            return new Data_Tuple.Tuple(false, Current.value);
        };
        if (_633 instanceof Root) {
            return new Data_Tuple.Tuple(false, Root.value);
        };
        if (_633 instanceof ParentIn && _633.value0 instanceof FileIn) {
            return new Data_Tuple.Tuple(true, Data_Tuple.snd(canonicalize$prime(_633.value0.value0)));
        };
        if (_633 instanceof ParentIn && _633.value0 instanceof DirIn) {
            return new Data_Tuple.Tuple(true, Data_Tuple.snd(canonicalize$prime(_633.value0.value0)));
        };
        if (_633 instanceof ParentIn) {
            return (function (_615) {
                var p$prime$prime = new ParentIn(_615.value1);
                if (_615.value0) {
                    return canonicalize$prime(p$prime$prime);
                };
                if (!_615.value0) {
                    return new Data_Tuple.Tuple(_615.value0, p$prime$prime);
                };
                throw new Error("Failed pattern match");
            })(canonicalize$prime(_633.value0));
        };
        if (_633 instanceof FileIn) {
            return Prelude["<$>"](Data_Tuple.functorTuple)(Prelude.flip(FileIn.create)(_633.value1))(canonicalize$prime(_633.value0));
        };
        if (_633 instanceof DirIn) {
            return Prelude["<$>"](Data_Tuple.functorTuple)(Prelude.flip(DirIn.create)(_633.value1))(canonicalize$prime(_633.value0));
        };
        throw new Error("Failed pattern match");
    };
    
    /**
     *  | Peels off the last directory and the terminal file or directory name 
     *  | from the path. Returns `Nothing` if there is no such pair (for example, 
     *  | if the last path segment is root directory, current directory, or parent 
     *  | directory).
     */
    var peel = function (_625) {
        if (_625 instanceof Current) {
            return Data_Maybe.Nothing.value;
        };
        if (_625 instanceof Root) {
            return Data_Maybe.Nothing.value;
        };
        if (_625 instanceof ParentIn) {
            return (function (_614) {
                if (_614.value0) {
                    return peel(_614.value1);
                };
                if (!_614.value0) {
                    return Data_Maybe.Nothing.value;
                };
                throw new Error("Failed pattern match");
            })(canonicalize$prime(_625));
        };
        if (_625 instanceof DirIn) {
            return Data_Maybe.Just.create(new Data_Tuple.Tuple(unsafeCoerceType(_625.value0), new Data_Either.Left(_625.value1)));
        };
        if (_625 instanceof FileIn) {
            return Data_Maybe.Just.create(new Data_Tuple.Tuple(unsafeCoerceType(_625.value0), new Data_Either.Right(_625.value1)));
        };
        throw new Error("Failed pattern match");
    };
    
    /**
     *  | Canonicalizes a path, by reducing things in the form `/x/../` to just `/x/`.
     */
    var canonicalize = function (p) {
        return Data_Tuple.snd(canonicalize$prime(p));
    };
    var eqPath = new Prelude.Eq(function (p1) {
        return function (p2) {
            return !Prelude["=="](eqPath)(p1)(p2);
        };
    }, function (p1) {
        return function (p2) {
            return identicalPath(canonicalize(p1))(canonicalize(p2));
        };
    });
    
    /**
     *  | Makes one path relative to another reference path, if possible, otherwise 
     *  | returns `Nothing`. The returned path inherits the sandbox settings of the 
     *  | reference path.
     *  | 
     *  | Note there are some cases this function cannot handle. 
     */
    var relativeTo = function (p1) {
        return function (p2) {
            var relativeTo$prime = function (p1_1) {
                return function (p2_1) {
                    var _788 = identicalPath(p1_1)(p2_1);
                    if (_788) {
                        return new Data_Maybe.Just(Current.value);
                    };
                    if (!_788) {
                        var _789 = peel(p1_1);
                        if (_789 instanceof Data_Maybe.Nothing) {
                            var _790 = new Data_Tuple.Tuple(p1_1, p2_1);
                            if (_790.value0 instanceof Root && _790.value1 instanceof Root) {
                                return new Data_Maybe.Just(Current.value);
                            };
                            if (_790.value0 instanceof Current && _790.value1 instanceof Current) {
                                return new Data_Maybe.Just(Current.value);
                            };
                            return Data_Maybe.Nothing.value;
                        };
                        if (_789 instanceof Data_Maybe.Just) {
                            return Prelude["<$>"](Data_Maybe.functorMaybe)(Prelude.flip($less$div$greater)(Data_Either.either(DirIn.create(Current.value))(FileIn.create(Current.value))(_789.value0.value1)))(relativeTo$prime(_789.value0.value0)(p2_1));
                        };
                        throw new Error("Failed pattern match");
                    };
                    throw new Error("Failed pattern match");
                };
            };
            return relativeTo$prime(canonicalize(p1))(canonicalize(p2));
        };
    };
    
    /**
     *  | Attempts to sandbox a path relative to some directory. If successful, the sandboxed 
     *  | directory will be returned relative to the sandbox directory (although this can easily
     *  | be converted into an absolute path using `</>`).
     *  | 
     *  | This combinator can be used to ensure that paths which originate from user-code
     *  | cannot access data outside a given directory.
     */
    var sandbox = function (p1) {
        return function (p2) {
            return relativeTo(p2)(p1);
        };
    };
    return {
        FileName: FileName, 
        Escaper: Escaper, 
        DirName: DirName, 
        "unsafePrintPath'": unsafePrintPath$prime, 
        unsafePrintPath: unsafePrintPath, 
        unsandbox: unsandbox, 
        sandbox: sandbox, 
        runEscaper: runEscaper, 
        rootDir: rootDir, 
        renameFile: renameFile, 
        relativeTo: relativeTo, 
        parseRelFile: parseRelFile, 
        parseRelDir: parseRelDir, 
        parsePath: parsePath, 
        posixEscaper: posixEscaper, 
        peel: peel, 
        "parentDir'": parentDir$prime, 
        identicalPath: identicalPath, 
        "file'": file$prime, 
        file: file, 
        extension: extension, 
        dropExtension: dropExtension, 
        "dir'": dir$prime, 
        dir: dir, 
        depth: depth, 
        currentDir: currentDir, 
        changeExtension: changeExtension, 
        canonicalize: canonicalize, 
        "<..>": $less$dot$dot$greater, 
        "<.>": $less$dot$greater, 
        "</>": $less$div$greater, 
        showPath: showPath, 
        eqPath: eqPath
    };
})();
var PS = PS || {};
PS.Examples = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Debug_Trace = PS.Debug_Trace;
    var Data_Path_Pathy = PS.Data_Path_Pathy;
    var Data_Maybe_Unsafe = PS.Data_Maybe_Unsafe;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    var Data_Maybe = PS.Data_Maybe;
    var test = function (__dict_Show_520) {
        return function (__dict_Eq_521) {
            return function (name) {
                return function (actual) {
                    return function (expected) {
                        return function __do() {
                            Debug_Trace.trace("Test: " + name)();
                            var _798 = Prelude["=="](__dict_Eq_521)(expected)(actual);
                            if (_798) {
                                return Debug_Trace.trace("Passed: " + Prelude.show(__dict_Show_520)(expected))();
                            };
                            if (!_798) {
                                return Debug_Trace.trace("Failed: Expected " + (Prelude.show(__dict_Show_520)(expected) + (" but found " + Prelude.show(__dict_Show_520)(actual))))();
                            };
                            throw new Error("Failed pattern match");
                        };
                    };
                };
            };
        };
    };
    var test$prime = function (n) {
        return function (p) {
            return function (s) {
                return test(Prelude.showString)(Prelude.eqString)(n)(Data_Path_Pathy.unsafePrintPath(p))(s);
            };
        };
    };
    var main = function __do() {
        Debug_Trace.trace("NEW TEST")();
        test$prime("(</>) - two directories")(Data_Path_Pathy["</>"](Data_Path_Pathy.dir("foo"))(Data_Path_Pathy.dir("bar")))("./foo/bar/")();
        test$prime("(</>) - file with two parents")(Data_Path_Pathy["</>"](Data_Path_Pathy["</>"](Data_Path_Pathy.dir("foo"))(Data_Path_Pathy.dir("bar")))(Data_Path_Pathy.file("image.png")))("./foo/bar/image.png")();
        test$prime("(<.>) - file without extension")(Data_Path_Pathy["<.>"](Data_Path_Pathy.file("image"))("png"))("./image.png")();
        test$prime("(<.>) - file with extension")(Data_Path_Pathy["<.>"](Data_Path_Pathy.file("image.jpg"))("png"))("./image.png")();
        test$prime("printPath - ./../")(Data_Path_Pathy["parentDir'"](Data_Path_Pathy.currentDir))("./../")();
        test$prime("(</>) - ./../foo/")(Data_Path_Pathy["</>"](Data_Path_Pathy["parentDir'"](Data_Path_Pathy.currentDir))(Data_Path_Pathy.unsandbox(Data_Path_Pathy.dir("foo"))))("./../foo/")();
        test$prime("parentDir' - ./../foo/../")(Data_Path_Pathy["</>"](Data_Path_Pathy["</>"](Data_Path_Pathy["parentDir'"](Data_Path_Pathy.currentDir))(Data_Path_Pathy.unsandbox(Data_Path_Pathy.dir("foo"))))(Data_Path_Pathy["parentDir'"](Data_Path_Pathy.currentDir)))("./../foo/../")();
        test$prime("(<..>) - ./../")(Data_Path_Pathy["<..>"](Data_Path_Pathy.currentDir)(Data_Path_Pathy.currentDir))("./../")();
        test$prime("(<..>) - ./../foo/")(Data_Path_Pathy["<..>"](Data_Path_Pathy.currentDir)(Data_Path_Pathy.dir("foo")))("./../foo/")();
        test$prime("(<..>) - ./../foo/../")(Data_Path_Pathy["<..>"](Data_Path_Pathy["<..>"](Data_Path_Pathy.currentDir)(Data_Path_Pathy.dir("foo")))(Data_Path_Pathy.currentDir))("./../foo/../")();
        test$prime("canonicalize - 1 down, 1 up")(Data_Path_Pathy.canonicalize(Data_Path_Pathy["parentDir'"](Data_Path_Pathy.dir("foo"))))("./")();
        test$prime("canonicalize - 2 down, 2 up")(Data_Path_Pathy.canonicalize(Data_Path_Pathy["parentDir'"](Data_Path_Pathy["parentDir'"](Data_Path_Pathy["</>"](Data_Path_Pathy.dir("foo"))(Data_Path_Pathy.dir("bar"))))))("./")();
        test$prime("renameFile - single level deep")(Data_Path_Pathy.renameFile(Data_Path_Pathy.dropExtension)(Data_Path_Pathy.file("image.png")))("./image")();
        test$prime("sandbox - sandbox absolute dir to one level higher")(Data_Maybe_Unsafe.fromJust(Data_Path_Pathy.sandbox(Data_Path_Pathy["</>"](Data_Path_Pathy.rootDir)(Data_Path_Pathy.dir("foo")))(Data_Path_Pathy["</>"](Data_Path_Pathy["</>"](Data_Path_Pathy.rootDir)(Data_Path_Pathy.dir("foo")))(Data_Path_Pathy.dir("bar")))))("./bar/")();
        test(Prelude.showNumber)(Prelude.eqNumber)("depth - negative")(Data_Path_Pathy.depth(Data_Path_Pathy["parentDir'"](Data_Path_Pathy["parentDir'"](Data_Path_Pathy["parentDir'"](Data_Path_Pathy.currentDir)))))(-3)();
        test(Data_Maybe.showMaybe(Data_Path_Pathy.showPath))(Data_Maybe.eqMaybe(Data_Path_Pathy.eqPath))("parseRelDir - empty string")(Data_Path_Pathy.parseRelDir(""))(Data_Maybe.Just.create(Data_Path_Pathy.currentDir))();
        return test(Data_Maybe.showMaybe(Data_Path_Pathy.showPath))(Data_Maybe.eqMaybe(Data_Path_Pathy.eqPath))("parseRelFile - image.png")(Data_Path_Pathy.parseRelFile("image.png"))(Data_Maybe.Just.create(Data_Path_Pathy.file("image.png")))();
    };
    return {
        main: main, 
        "test'": test$prime, 
        test: test
    };
})();
PS.Examples.main();
